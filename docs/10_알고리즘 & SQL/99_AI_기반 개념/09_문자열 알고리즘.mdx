# ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜

## ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜ì´ë€?

ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜ì€ í…ìŠ¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê³  ë¶„ì„í•˜ëŠ” ë°©ë²•ë“¤ì…ë‹ˆë‹¤.

ë§ˆì¹˜ ì±…ì—ì„œ íŠ¹ì • ë‹¨ì–´ë¥¼ ì°¾ê±°ë‚˜, ë¬¸ì¥ì„ ë¶„ì„í•˜ëŠ” ê²ƒê³¼ ê°™ìŠµë‹ˆë‹¤.
- íŒ¨í„´ ë§¤ì¹­: íŠ¹ì • ë¬¸ìì—´ ì°¾ê¸°
- ë¬¸ìì—´ ë³€í™˜: í•œ ë¬¸ìì—´ì„ ë‹¤ë¥¸ ë¬¸ìì—´ë¡œ ë°”ê¾¸ê¸°
- ë¬¸ìì—´ ë¶„ì„: ë¬¸ìì—´ì˜ íŠ¹ì„± íŒŒì•…í•˜ê¸°

```
ì˜ˆì‹œ:
í…ìŠ¤íŠ¸: "Hello World Programming"
íŒ¨í„´: "World"
ê²°ê³¼: ì¸ë±ìŠ¤ 6ì—ì„œ ë°œê²¬
```

## ê¸°ë³¸ íŒ¨í„´ ë§¤ì¹­

### ë‹¨ìˆœí•œ ë¬¸ìì—´ ê²€ìƒ‰

```javascript
// ê°€ì¥ ê¸°ë³¸ì ì¸ ë°©ë²•
function naiveStringSearch(text, pattern) {
    const positions = [];
    
    for (let i = 0; i <= text.length - pattern.length; i++) {
        let match = true;
        
        for (let j = 0; j < pattern.length; j++) {
            if (text[i + j] !== pattern[j]) {
                match = false;
                break;
            }
        }
        
        if (match) {
            positions.push(i);
        }
    }
    
    return positions;
}

// ì²« ë²ˆì§¸ ë§¤ì¹˜ë§Œ ì°¾ê¸°
function findFirst(text, pattern) {
    for (let i = 0; i <= text.length - pattern.length; i++) {
        let match = true;
        
        for (let j = 0; j < pattern.length; j++) {
            if (text[i + j] !== pattern[j]) {
                match = false;
                break;
            }
        }
        
        if (match) return i;
    }
    
    return -1;
}

const text = "AABAACAADAABAABA";
const pattern = "AABA";
console.log(naiveStringSearch(text, pattern)); // [0, 9, 12]
console.log(findFirst(text, pattern)); // 0
```

### JavaScript ë‚´ì¥ ë©”ì„œë“œì™€ ë¹„êµ

```javascript
function compareStringSearchMethods() {
    const longText = "A".repeat(10000) + "PATTERN" + "B".repeat(10000);
    const pattern = "PATTERN";
    const iterations = 1000;
    
    // ë‹¨ìˆœ ê²€ìƒ‰
    let start = performance.now();
    for (let i = 0; i < iterations; i++) {
        naiveStringSearch(longText, pattern);
    }
    let end = performance.now();
    const naiveTime = end - start;
    
    // JavaScript ë‚´ì¥ indexOf
    start = performance.now();
    for (let i = 0; i < iterations; i++) {
        longText.indexOf(pattern);
    }
    end = performance.now();
    const indexOfTime = end - start;
    
    // JavaScript ë‚´ì¥ includes
    start = performance.now();
    for (let i = 0; i < iterations; i++) {
        longText.includes(pattern);
    }
    end = performance.now();
    const includesTime = end - start;
    
    // ì •ê·œì‹
    const regex = new RegExp(pattern, 'g');
    start = performance.now();
    for (let i = 0; i < iterations; i++) {
        [...longText.matchAll(regex)];
    }
    end = performance.now();
    const regexTime = end - start;
    
    console.log(`ë‹¨ìˆœ ê²€ìƒ‰: ${naiveTime.toFixed(2)}ms`);
    console.log(`indexOf: ${indexOfTime.toFixed(2)}ms`);
    console.log(`includes: ${includesTime.toFixed(2)}ms`);
    console.log(`ì •ê·œì‹: ${regexTime.toFixed(2)}ms`);
}
```

> JavaScript ë‚´ì¥ ë©”ì„œë“œë“¤ì´ í›¨ì”¬ ë¹ ë¦…ë‹ˆë‹¤

## KMP ì•Œê³ ë¦¬ì¦˜

KMP(Knuth-Morris-Pratt) ì•Œê³ ë¦¬ì¦˜ì€ ì‹¤íŒ¨ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ íš¨ìœ¨ì ìœ¼ë¡œ íŒ¨í„´ì„ ì°¾ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

### ì‹¤íŒ¨ í•¨ìˆ˜ êµ¬ì„±

```javascript
function buildFailureFunction(pattern) {
    const failure = Array(pattern.length).fill(0);
    let j = 0;
    
    for (let i = 1; i < pattern.length; i++) {
        while (j > 0 && pattern[i] !== pattern[j]) {
            j = failure[j - 1];
        }
        
        if (pattern[i] === pattern[j]) {
            j++;
        }
        
        failure[i] = j;
    }
    
    return failure;
}

// ì‹¤íŒ¨ í•¨ìˆ˜ ì‹œê°í™”
function visualizeFailureFunction(pattern) {
    const failure = buildFailureFunction(pattern);
    
    console.log(`íŒ¨í„´: ${pattern}`);
    console.log(`ì¸ë±ìŠ¤: ${pattern.split('').map((_, i) => i).join(' ')}`);
    console.log(`ì‹¤íŒ¨í•¨ìˆ˜: ${failure.join(' ')}`);
    
    return failure;
}

visualizeFailureFunction("AABAACAAB");
// íŒ¨í„´: AABAACAAB
// ì¸ë±ìŠ¤: 0 1 2 3 4 5 6 7 8
// ì‹¤íŒ¨í•¨ìˆ˜: 0 1 0 1 2 0 1 2 3
```

### KMP ê²€ìƒ‰ êµ¬í˜„

```javascript
function kmpSearch(text, pattern) {
    const failure = buildFailureFunction(pattern);
    const matches = [];
    let j = 0;
    
    for (let i = 0; i < text.length; i++) {
        while (j > 0 && text[i] !== pattern[j]) {
            j = failure[j - 1];
        }
        
        if (text[i] === pattern[j]) {
            j++;
        }
        
        if (j === pattern.length) {
            matches.push(i - pattern.length + 1);
            j = failure[j - 1];
        }
    }
    
    return matches;
}

console.log(kmpSearch("AABAACAADAABAABA", "AABA")); // [0, 9, 12]
```

### ì„±ëŠ¥ ë¹„êµ

```javascript
function comparePatternMatching() {
    // ìµœì•…ì˜ ê²½ìš°ë¥¼ ë§Œë“œëŠ” í…ìŠ¤íŠ¸ì™€ íŒ¨í„´
    const worstCaseText = "A".repeat(1000) + "B";
    const worstCasePattern = "A".repeat(10) + "B";
    
    // ì¼ë°˜ì ì¸ ê²½ìš°
    const normalText = "Lorem ipsum dolor sit amet consectetur adipiscing elit";
    const normalPattern = "consectetur";
    
    function testAlgorithm(text, pattern, name) {
        console.log(`\n=== ${name} ===`);
        
        let start = performance.now();
        const naiveResult = naiveStringSearch(text, pattern);
        let end = performance.now();
        const naiveTime = end - start;
        
        start = performance.now();
        const kmpResult = kmpSearch(text, pattern);
        end = performance.now();
        const kmpTime = end - start;
        
        start = performance.now();
        const indexOfResult = [];
        let index = text.indexOf(pattern);
        while (index !== -1) {
            indexOfResult.push(index);
            index = text.indexOf(pattern, index + 1);
        }
        end = performance.now();
        const indexOfTime = end - start;
        
        console.log(`ë‹¨ìˆœ ê²€ìƒ‰: ${naiveTime.toFixed(4)}ms, ê²°ê³¼: [${naiveResult.join(', ')}]`);
        console.log(`KMP: ${kmpTime.toFixed(4)}ms, ê²°ê³¼: [${kmpResult.join(', ')}]`);
        console.log(`indexOf: ${indexOfTime.toFixed(4)}ms, ê²°ê³¼: [${indexOfResult.join(', ')}]`);
    }
    
    testAlgorithm(worstCaseText, worstCasePattern, "ìµœì•…ì˜ ê²½ìš°");
    testAlgorithm(normalText, normalPattern, "ì¼ë°˜ì ì¸ ê²½ìš°");
}
```

> ì¼ë°˜ì ìœ¼ë¡œëŠ” JavaScript ë‚´ì¥ ë©”ì„œë“œê°€ ê°€ì¥ ë¹ ë¥´ì§€ë§Œ, KMPëŠ” ìµœì•…ì˜ ê²½ìš°ì—ì„œ ìš°ìˆ˜í•œ ì„±ëŠ¥ì„ ë³´ì…ë‹ˆë‹¤

## ë¼ë¹ˆ-ì¹´í”„ ì•Œê³ ë¦¬ì¦˜

í•´ì‹œë¥¼ ì‚¬ìš©í•´ì„œ íŒ¨í„´ì„ ì°¾ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

```javascript
function rabinKarpSearch(text, pattern, prime = 101) {
    const patternLength = pattern.length;
    const textLength = text.length;
    const base = 256; // ë¬¸ì ì§‘í•© í¬ê¸°
    
    let patternHash = 0;
    let textHash = 0;
    let h = 1;
    const matches = [];
    
    // h = pow(base, patternLength-1) % prime
    for (let i = 0; i < patternLength - 1; i++) {
        h = (h * base) % prime;
    }
    
    // íŒ¨í„´ê³¼ ì²« ë²ˆì§¸ ìœˆë„ìš°ì˜ í•´ì‹œ ê³„ì‚°
    for (let i = 0; i < patternLength; i++) {
        patternHash = (base * patternHash + pattern.charCodeAt(i)) % prime;
        textHash = (base * textHash + text.charCodeAt(i)) % prime;
    }
    
    // ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¡œ í…ìŠ¤íŠ¸ ê²€ìƒ‰
    for (let i = 0; i <= textLength - patternLength; i++) {
        // í•´ì‹œê°€ ê°™ìœ¼ë©´ ì‹¤ì œ ë¬¸ìì—´ ë¹„êµ
        if (patternHash === textHash) {
            let match = true;
            for (let j = 0; j < patternLength; j++) {
                if (text[i + j] !== pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                matches.push(i);
            }
        }
        
        // ë‹¤ìŒ ìœˆë„ìš°ì˜ í•´ì‹œ ê³„ì‚° (ë¡¤ë§ í•´ì‹œ)
        if (i < textLength - patternLength) {
            textHash = (base * (textHash - text.charCodeAt(i) * h) + 
                       text.charCodeAt(i + patternLength)) % prime;
            
            // ìŒìˆ˜ê°€ ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë³´ì •
            if (textHash < 0) {
                textHash += prime;
            }
        }
    }
    
    return matches;
}

console.log(rabinKarpSearch("AABAACAADAABAABA", "AABA")); // [0, 9, 12]
```

## ë¬¸ìì—´ ë³€í™˜ ì•Œê³ ë¦¬ì¦˜

### í¸ì§‘ ê±°ë¦¬ (ë ˆë²¤ìŠˆíƒ€ì¸ ê±°ë¦¬)

```javascript
function editDistance(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    
    // DP í…Œì´ë¸” ì´ˆê¸°í™”
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // ì²« ë²ˆì§¸ í–‰ê³¼ ì—´ ì´ˆê¸°í™”
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    // DP í…Œì´ë¸” ì±„ìš°ê¸°
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]; // ê°™ìœ¼ë©´ ë³€ê²½ ë¶ˆí•„ìš”
            } else {
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,     // ì‚­ì œ
                    dp[i][j - 1] + 1,     // ì‚½ì…
                    dp[i - 1][j - 1] + 1  // êµì²´
                );
            }
        }
    }
    
    return dp[m][n];
}

// í¸ì§‘ ê³¼ì • ì¶”ì 
function editDistanceWithPath(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    const operations = [];
    
    // ì´ˆê¸°í™”
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    
    // DP ê³„ì‚°
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i - 1][j - 1] + 1
                );
            }
        }
    }
    
    // ê²½ë¡œ ì¶”ì 
    let i = m, j = n;
    while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && str1[i - 1] === str2[j - 1]) {
            i--; j--;
        } else if (i > 0 && j > 0 && dp[i][j] === dp[i - 1][j - 1] + 1) {
            operations.unshift(`êµì²´: ${str1[i - 1]} â†’ ${str2[j - 1]} (ìœ„ì¹˜ ${i - 1})`);
            i--; j--;
        } else if (i > 0 && dp[i][j] === dp[i - 1][j] + 1) {
            operations.unshift(`ì‚­ì œ: ${str1[i - 1]} (ìœ„ì¹˜ ${i - 1})`);
            i--;
        } else if (j > 0 && dp[i][j] === dp[i][j - 1] + 1) {
            operations.unshift(`ì‚½ì…: ${str2[j - 1]} (ìœ„ì¹˜ ${i})`);
            j--;
        }
    }
    
    return {
        distance: dp[m][n],
        operations: operations
    };
}

console.log(editDistance("kitten", "sitting")); // 3
const result = editDistanceWithPath("kitten", "sitting");
console.log(result);
// {distance: 3, operations: ["êµì²´: k â†’ s (ìœ„ì¹˜ 0)", "êµì²´: e â†’ i (ìœ„ì¹˜ 4)", "ì‚½ì…: g (ìœ„ì¹˜ 6)"]}
```

### ìµœì¥ ê³µí†µ ë¶€ë¶„ ë¬¸ìì—´

```javascript
function longestCommonSubstring(str1, str2) {
    const m = str1.length;
    const n = str2.length;
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    let maxLength = 0;
    let endingPos = 0;
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (str1[i - 1] === str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxLength) {
                    maxLength = dp[i][j];
                    endingPos = i;
                }
            }
        }
    }
    
    return {
        length: maxLength,
        substring: str1.substring(endingPos - maxLength, endingPos)
    };
}

console.log(longestCommonSubstring("GeeksforGeeks", "GeeksQuiz"));
// {length: 5, substring: "Geeks"}
```

## ë¬¸ìì—´ ë¶„ì„

### íŒ°ë¦°ë“œë¡¬ ê²€ì‚¬

```javascript
// ë‹¨ìˆœí•œ ë°©ë²•
function isPalindrome(str) {
    const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');
    return cleaned === cleaned.split('').reverse().join('');
}

// íˆ¬ í¬ì¸í„° ë°©ë²• (ë” íš¨ìœ¨ì )
function isPalindromeOptimized(str) {
    const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');
    let left = 0;
    let right = cleaned.length - 1;
    
    while (left < right) {
        if (cleaned[left] !== cleaned[right]) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}

// ê°€ì¥ ê¸´ íŒ°ë¦°ë“œë¡¬ ë¶€ë¶„ ë¬¸ìì—´ ì°¾ê¸°
function longestPalindrome(s) {
    if (!s || s.length < 2) return s;
    
    let start = 0;
    let maxLength = 1;
    
    function expandAroundCenter(left, right) {
        while (left >= 0 && right < s.length && s[left] === s[right]) {
            const currentLength = right - left + 1;
            if (currentLength > maxLength) {
                start = left;
                maxLength = currentLength;
            }
            left--;
            right++;
        }
    }
    
    for (let i = 0; i < s.length; i++) {
        expandAroundCenter(i, i);     // í™€ìˆ˜ ê¸¸ì´ íŒ°ë¦°ë“œë¡¬
        expandAroundCenter(i, i + 1); // ì§ìˆ˜ ê¸¸ì´ íŒ°ë¦°ë“œë¡¬
    }
    
    return s.substring(start, start + maxLength);
}

console.log(isPalindrome("A man, a plan, a canal: Panama")); // true
console.log(longestPalindrome("babad")); // "bab" ë˜ëŠ” "aba"
```

### ì• ë„ˆê·¸ë¨ ê²€ì‚¬

```javascript
function isAnagram(str1, str2) {
    if (str1.length !== str2.length) return false;
    
    const count = {};
    
    // ì²« ë²ˆì§¸ ë¬¸ìì—´ì˜ ë¬¸ì ê°œìˆ˜ ì„¸ê¸°
    for (let char of str1) {
        count[char] = (count[char] || 0) + 1;
    }
    
    // ë‘ ë²ˆì§¸ ë¬¸ìì—´ì˜ ë¬¸ì ê°œìˆ˜ ë¹¼ê¸°
    for (let char of str2) {
        if (!count[char]) return false;
        count[char]--;
    }
    
    return true;
}

// ê·¸ë£¹í™”
function groupAnagrams(strs) {
    const groups = {};
    
    for (let str of strs) {
        const sorted = str.split('').sort().join('');
        if (!groups[sorted]) {
            groups[sorted] = [];
        }
        groups[sorted].push(str);
    }
    
    return Object.values(groups);
}

console.log(isAnagram("listen", "silent")); // true
console.log(groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]));
// [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

## ê³ ê¸‰ ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜

### ì ‘ë¯¸ì‚¬ ë°°ì—´ (Suffix Array)

```javascript
function buildSuffixArray(str) {
    const suffixes = [];
    
    // ëª¨ë“  ì ‘ë¯¸ì‚¬ ìƒì„±
    for (let i = 0; i < str.length; i++) {
        suffixes.push({
            suffix: str.substring(i),
            index: i
        });
    }
    
    // ì ‘ë¯¸ì‚¬ë“¤ì„ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬
    suffixes.sort((a, b) => a.suffix.localeCompare(b.suffix));
    
    return suffixes.map(item => item.index);
}

// ì ‘ë¯¸ì‚¬ ë°°ì—´ì„ ì´ìš©í•œ íŒ¨í„´ ê²€ìƒ‰
function searchWithSuffixArray(str, pattern) {
    const suffixArray = buildSuffixArray(str);
    const matches = [];
    
    for (let i of suffixArray) {
        if (str.substring(i, i + pattern.length) === pattern) {
            matches.push(i);
        }
    }
    
    return matches.sort((a, b) => a - b);
}

const text = "banana";
console.log(buildSuffixArray(text)); // [5, 3, 1, 0, 4, 2]
console.log(searchWithSuffixArray(text, "ana")); // [1, 3]
```

### Z ì•Œê³ ë¦¬ì¦˜

```javascript
function zAlgorithm(str) {
    const n = str.length;
    const z = Array(n).fill(0);
    let left = 0, right = 0;
    
    for (let i = 1; i < n; i++) {
        if (i <= right) {
            z[i] = Math.min(right - i + 1, z[i - left]);
        }
        
        while (i + z[i] < n && str[z[i]] === str[i + z[i]]) {
            z[i]++;
        }
        
        if (i + z[i] - 1 > right) {
            left = i;
            right = i + z[i] - 1;
        }
    }
    
    return z;
}

// Z ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•œ íŒ¨í„´ ê²€ìƒ‰
function zPatternSearch(text, pattern) {
    const combined = pattern + '$' + text;
    const z = zAlgorithm(combined);
    const matches = [];
    
    for (let i = 0; i < z.length; i++) {
        if (z[i] === pattern.length) {
            matches.push(i - pattern.length - 1);
        }
    }
    
    return matches;
}

console.log(zPatternSearch("AABAACAADAABAABA", "AABA")); // [0, 9, 12]
```

## ì‹¤ì œ ë¬¸ì œ ì‘ìš©

### ë¬¸ìì—´ ì••ì¶•

```javascript
function compressString(str) {
    if (!str) return str;
    
    let compressed = '';
    let count = 1;
    
    for (let i = 1; i < str.length; i++) {
        if (str[i] === str[i - 1]) {
            count++;
        } else {
            compressed += str[i - 1] + count;
            count = 1;
        }
    }
    
    compressed += str[str.length - 1] + count;
    
    return compressed.length < str.length ? compressed : str;
}

console.log(compressString("aabcccccaaa")); // "a2b1c5a3"
console.log(compressString("abc")); // "abc" (ì••ì¶•í•˜ë©´ ë” ê¸¸ì–´ì§)
```

### ë‹¨ì–´ íŒ¨í„´ ë§¤ì¹­

```javascript
function wordPattern(pattern, str) {
    const words = str.split(' ');
    
    if (pattern.length !== words.length) return false;
    
    const charToWord = {};
    const wordToChar = {};
    
    for (let i = 0; i < pattern.length; i++) {
        const char = pattern[i];
        const word = words[i];
        
        if (charToWord[char] && charToWord[char] !== word) return false;
        if (wordToChar[word] && wordToChar[word] !== char) return false;
        
        charToWord[char] = word;
        wordToChar[word] = char;
    }
    
    return true;
}

console.log(wordPattern("abba", "dog cat cat dog")); // true
console.log(wordPattern("abba", "dog cat cat fish")); // false
```

## ì„±ëŠ¥ ìµœì í™” íŒ

```javascript
function stringOptimizationTips() {
    console.log("ë¬¸ìì—´ ì²˜ë¦¬ ìµœì í™” íŒ:");
    
    console.log("\n1. ë¬¸ìì—´ ì—°ê²°:");
    console.log("âŒ ëŠë¦° ë°©ë²•: str += char (ë°˜ë³µë¬¸ì—ì„œ)");
    console.log("âœ… ë¹ ë¥¸ ë°©ë²•: array.push(char), array.join('')");
    
    console.log("\n2. ë¬¸ìì—´ ê²€ìƒ‰:");
    console.log("âŒ indexOfë¥¼ ë°˜ë³µ í˜¸ì¶œ");
    console.log("âœ… ì •ê·œì‹ matchAll ë˜ëŠ” ì „ìš© ì•Œê³ ë¦¬ì¦˜");
    
    console.log("\n3. ëŒ€ì†Œë¬¸ì ë³€í™˜:");
    console.log("âŒ ë§¤ë²ˆ toLowerCase() í˜¸ì¶œ");
    console.log("âœ… ë¯¸ë¦¬ ë³€í™˜í•˜ê±°ë‚˜ charCode ë¹„êµ");
    
    console.log("\n4. ë¬¸ìì—´ ë¶„í• :");
    console.log("âŒ ë¶ˆí•„ìš”í•œ split() ì‚¬ìš©");
    console.log("âœ… ì¸ë±ìŠ¤ ê¸°ë°˜ ì ‘ê·¼");
}

// ë¬¸ìì—´ ì—°ê²° ì„±ëŠ¥ ë¹„êµ
function compareStringConcatenation() {
    const iterations = 10000;
    
    // ë°©ë²• 1: += ì—°ì‚°ì
    let start = performance.now();
    let str1 = '';
    for (let i = 0; i < iterations; i++) {
        str1 += 'a';
    }
    let end = performance.now();
    const plusTime = end - start;
    
    // ë°©ë²• 2: ë°°ì—´ + join
    start = performance.now();
    const arr = [];
    for (let i = 0; i < iterations; i++) {
        arr.push('a');
    }
    const str2 = arr.join('');
    end = performance.now();
    const joinTime = end - start;
    
    console.log(`+= ì—°ì‚°ì: ${plusTime.toFixed(2)}ms`);
    console.log(`ë°°ì—´ + join: ${joinTime.toFixed(2)}ms`);
}
```

> ì¼ë°˜ì ìœ¼ë¡œ JavaScript ì—”ì§„ì´ ìµœì í™”ë¥¼ ì˜ í•´ì£¼ì§€ë§Œ, ëŒ€ìš©ëŸ‰ ë¬¸ìì—´ ì²˜ë¦¬ì‹œì—ëŠ” ë°°ì—´ + joinì´ ë” íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ì–¸ì œ ì–´ë–¤ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ë‚˜ìš”?

```javascript
function chooseStringAlgorithm() {
    console.log("ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ê°€ì´ë“œ:");
    
    console.log("\nğŸ” íŒ¨í„´ ê²€ìƒ‰:");
    console.log("- ì¼ë°˜ì ì¸ ê²½ìš°: JavaScript ë‚´ì¥ ë©”ì„œë“œ");
    console.log("- ë§ì€ íŒ¨í„´ ê²€ìƒ‰: KMP ë˜ëŠ” ë¼ë¹ˆ-ì¹´í”„");
    console.log("- ì „ì²˜ë¦¬ ê°€ëŠ¥í•œ í…ìŠ¤íŠ¸: ì ‘ë¯¸ì‚¬ ë°°ì—´");
    
    console.log("\nğŸ“ ë¬¸ìì—´ ë³€í™˜:");
    console.log("- ìœ ì‚¬ë„ ì¸¡ì •: í¸ì§‘ ê±°ë¦¬");
    console.log("- ê³µí†µ ë¶€ë¶„ ì°¾ê¸°: LCS ì•Œê³ ë¦¬ì¦˜");
    console.log("- íŒ¨í„´ ë§¤ì¹­: ì •ê·œì‹");
    
    console.log("\nğŸ”¬ ë¬¸ìì—´ ë¶„ì„:");
    console.log("- íŒ°ë¦°ë“œë¡¬: íˆ¬ í¬ì¸í„°");
    console.log("- ì• ë„ˆê·¸ë¨: ë¬¸ì ê°œìˆ˜ ë¹„êµ");
    console.log("- íŒ¨í„´ ë¶„ì„: Z ì•Œê³ ë¦¬ì¦˜");
}
```

ë¬¸ìì—´ ì•Œê³ ë¦¬ì¦˜ì€ í…ìŠ¤íŠ¸ ì²˜ë¦¬, ê²€ìƒ‰ ì—”ì§„, ìƒë¬¼ì •ë³´í•™ ë“± ë‹¤ì–‘í•œ ë¶„ì•¼ì—ì„œ í™œìš©ë©ë‹ˆë‹¤. ë¬¸ì œì˜ íŠ¹ì„±ì— ë§ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.
