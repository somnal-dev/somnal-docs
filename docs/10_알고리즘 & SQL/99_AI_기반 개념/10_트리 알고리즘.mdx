# íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜

## íŠ¸ë¦¬ë€?

íŠ¸ë¦¬ëŠ” ê³„ì¸µì  êµ¬ì¡°ë¥¼ ê°€ì§„ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤.

ë§ˆì¹˜ ê°€ì¡± ê´€ê³„ë„ë‚˜ íšŒì‚¬ ì¡°ì§ë„ì²˜ëŸ¼ ë¶€ëª¨-ìì‹ ê´€ê³„ë¡œ ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
- ë£¨íŠ¸(Root): ê°€ì¥ ìœ„ì— ìˆëŠ” ë…¸ë“œ
- ë¶€ëª¨(Parent): ìœ„ìª½ ë…¸ë“œ
- ìì‹(Children): ì•„ë˜ìª½ ë…¸ë“œë“¤
- ì(Leaf): ìì‹ì´ ì—†ëŠ” ë…¸ë“œ

```
íŠ¸ë¦¬ ì˜ˆì‹œ:
       A (ë£¨íŠ¸)
      / \
     B   C
    / \   \
   D   E   F (ì ë…¸ë“œë“¤)
```

## ì´ì§„ íŠ¸ë¦¬

ê°€ì¥ ê¸°ë³¸ì ì¸ íŠ¸ë¦¬ë¡œ, ê° ë…¸ë“œê°€ ìµœëŒ€ 2ê°œì˜ ìì‹ì„ ê°€ì§‘ë‹ˆë‹¤.

### ì´ì§„ íŠ¸ë¦¬ êµ¬í˜„

```javascript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// íŠ¸ë¦¬ ìƒì„± ì˜ˆì‹œ
function createSampleTree() {
    const root = new TreeNode(1);
    root.left = new TreeNode(2);
    root.right = new TreeNode(3);
    root.left.left = new TreeNode(4);
    root.left.right = new TreeNode(5);
    root.right.left = new TreeNode(6);
    root.right.right = new TreeNode(7);
    
    return root;
}

/*
ìƒì„±ëœ íŠ¸ë¦¬:
       1
      / \
     2   3
    / \ / \
   4  5 6  7
*/
```

### íŠ¸ë¦¬ ìˆœíšŒ

#### ì „ìœ„ ìˆœíšŒ (Pre-order): ë£¨íŠ¸ â†’ ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½

```javascript
function preorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        result.push(node.val);    // ë£¨íŠ¸ ë°©ë¬¸
        traverse(node.left);      // ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬
        traverse(node.right);     // ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬
    }
    
    traverse(root);
    return result;
}

// ë°˜ë³µë¬¸ ë²„ì „
function preorderIterative(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [root];
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val);
        
        if (node.right) stack.push(node.right);
        if (node.left) stack.push(node.left);
    }
    
    return result;
}

const tree = createSampleTree();
console.log(preorderTraversal(tree)); // [1, 2, 4, 5, 3, 6, 7]
```

#### ì¤‘ìœ„ ìˆœíšŒ (In-order): ì™¼ìª½ â†’ ë£¨íŠ¸ â†’ ì˜¤ë¥¸ìª½

```javascript
function inorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        traverse(node.left);      // ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬
        result.push(node.val);    // ë£¨íŠ¸ ë°©ë¬¸
        traverse(node.right);     // ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬
    }
    
    traverse(root);
    return result;
}

// ë°˜ë³µë¬¸ ë²„ì „
function inorderIterative(root) {
    const result = [];
    const stack = [];
    let current = root;
    
    while (current || stack.length > 0) {
        while (current) {
            stack.push(current);
            current = current.left;
        }
        
        current = stack.pop();
        result.push(current.val);
        current = current.right;
    }
    
    return result;
}

console.log(inorderTraversal(tree)); // [4, 2, 5, 1, 6, 3, 7]
```

#### í›„ìœ„ ìˆœíšŒ (Post-order): ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½ â†’ ë£¨íŠ¸

```javascript
function postorderTraversal(root) {
    const result = [];
    
    function traverse(node) {
        if (!node) return;
        
        traverse(node.left);      // ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬
        traverse(node.right);     // ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬
        result.push(node.val);    // ë£¨íŠ¸ ë°©ë¬¸
    }
    
    traverse(root);
    return result;
}

// ë°˜ë³µë¬¸ ë²„ì „ (ì¢€ ë” ë³µì¡)
function postorderIterative(root) {
    if (!root) return [];
    
    const result = [];
    const stack = [];
    let lastVisited = null;
    
    while (stack.length > 0 || root) {
        if (root) {
            stack.push(root);
            root = root.left;
        } else {
            const peekNode = stack[stack.length - 1];
            if (peekNode.right && lastVisited !== peekNode.right) {
                root = peekNode.right;
            } else {
                result.push(peekNode.val);
                lastVisited = stack.pop();
            }
        }
    }
    
    return result;
}

console.log(postorderTraversal(tree)); // [4, 5, 2, 6, 7, 3, 1]
```

#### ë ˆë²¨ ìˆœíšŒ (Level-order): ë ˆë²¨ë³„ë¡œ ì™¼ìª½ë¶€í„°

```javascript
function levelOrderTraversal(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node.val);
        
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
    }
    
    return result;
}

// ë ˆë²¨ë³„ë¡œ ë¶„ë¦¬í•´ì„œ ë°˜í™˜
function levelOrderByLevels(root) {
    if (!root) return [];
    
    const result = [];
    let currentLevel = [root];
    
    while (currentLevel.length > 0) {
        const levelValues = [];
        const nextLevel = [];
        
        for (let node of currentLevel) {
            levelValues.push(node.val);
            
            if (node.left) nextLevel.push(node.left);
            if (node.right) nextLevel.push(node.right);
        }
        
        result.push(levelValues);
        currentLevel = nextLevel;
    }
    
    return result;
}

console.log(levelOrderTraversal(tree)); // [1, 2, 3, 4, 5, 6, 7]
console.log(levelOrderByLevels(tree)); // [[1], [2, 3], [4, 5, 6, 7]]
```

### ìˆœíšŒ ë°©ë²• ì„±ëŠ¥ ë¹„êµ

```javascript
function compareTraversalMethods() {
    // í° íŠ¸ë¦¬ ìƒì„±
    function createLargeTree(depth, value = 1) {
        if (depth === 0) return null;
        
        const node = new TreeNode(value);
        node.left = createLargeTree(depth - 1, value * 2);
        node.right = createLargeTree(depth - 1, value * 2 + 1);
        return node;
    }
    
    const largeTree = createLargeTree(15); // 2^15 - 1 = 32767ê°œ ë…¸ë“œ
    
    const methods = {
        'ì „ìœ„(ì¬ê·€)': () => preorderTraversal(largeTree),
        'ì „ìœ„(ë°˜ë³µ)': () => preorderIterative(largeTree),
        'ì¤‘ìœ„(ì¬ê·€)': () => inorderTraversal(largeTree),
        'ì¤‘ìœ„(ë°˜ë³µ)': () => inorderIterative(largeTree),
        'ë ˆë²¨ìˆœíšŒ': () => levelOrderTraversal(largeTree)
    };
    
    Object.entries(methods).forEach(([name, method]) => {
        const start = performance.now();
        const result = method();
        const end = performance.now();
        
        console.log(`${name}: ${(end - start).toFixed(2)}ms (ë…¸ë“œ ${result.length}ê°œ)`);
    });
}
```

> ì¼ë°˜ì ìœ¼ë¡œ ë°˜ë³µë¬¸ ë²„ì „ì´ ì¬ê·€ ë²„ì „ë³´ë‹¤ ì•½ê°„ ë¹ ë¥´ê³  ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ìœ„í—˜ì´ ì—†ìŠµë‹ˆë‹¤

## ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ (BST)

ì™¼ìª½ ìì‹ì€ ë¶€ëª¨ë³´ë‹¤ ì‘ê³ , ì˜¤ë¥¸ìª½ ìì‹ì€ ë¶€ëª¨ë³´ë‹¤ í° íŠ¸ë¦¬ì…ë‹ˆë‹¤.

### BST êµ¬í˜„

```javascript
class BinarySearchTree {
    constructor() {
        this.root = null;
    }
    
    insert(val) {
        const newNode = new TreeNode(val);
        
        if (!this.root) {
            this.root = newNode;
            return this;
        }
        
        let current = this.root;
        while (true) {
            if (val === current.val) return undefined; // ì¤‘ë³µ ê°’
            
            if (val < current.val) {
                if (!current.left) {
                    current.left = newNode;
                    return this;
                }
                current = current.left;
            } else {
                if (!current.right) {
                    current.right = newNode;
                    return this;
                }
                current = current.right;
            }
        }
    }
    
    search(val) {
        let current = this.root;
        
        while (current) {
            if (val === current.val) return true;
            if (val < current.val) {
                current = current.left;
            } else {
                current = current.right;
            }
        }
        
        return false;
    }
    
    delete(val) {
        this.root = this.deleteNode(this.root, val);
    }
    
    deleteNode(node, val) {
        if (!node) return null;
        
        if (val < node.val) {
            node.left = this.deleteNode(node.left, val);
        } else if (val > node.val) {
            node.right = this.deleteNode(node.right, val);
        } else {
            // ì‚­ì œí•  ë…¸ë“œ ë°œê²¬
            if (!node.left) return node.right;
            if (!node.right) return node.left;
            
            // ë‘ ìì‹ì´ ëª¨ë‘ ìˆëŠ” ê²½ìš°
            const minRight = this.findMin(node.right);
            node.val = minRight.val;
            node.right = this.deleteNode(node.right, minRight.val);
        }
        
        return node;
    }
    
    findMin(node = this.root) {
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    
    findMax(node = this.root) {
        while (node.right) {
            node = node.right;
        }
        return node;
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
const bst = new BinarySearchTree();
[15, 10, 20, 8, 12, 25].forEach(val => bst.insert(val));

console.log(bst.search(12)); // true
console.log(bst.search(7));  // false
```

### BST vs ë°°ì—´ ì„±ëŠ¥ ë¹„êµ

```javascript
function compareBSTvsArray() {
    const size = 10000;
    const values = Array.from({length: size}, () => Math.floor(Math.random() * size * 10));
    
    // BST êµ¬ì„±
    const bst = new BinarySearchTree();
    let start = performance.now();
    values.forEach(val => bst.insert(val));
    let end = performance.now();
    const bstInsertTime = end - start;
    
    // ë°°ì—´ êµ¬ì„±
    const arr = [];
    start = performance.now();
    values.forEach(val => {
        if (!arr.includes(val)) arr.push(val);
    });
    end = performance.now();
    const arrayInsertTime = end - start;
    
    // ì •ë ¬ëœ ë°°ì—´ êµ¬ì„±
    const sortedArr = [...new Set(values)].sort((a, b) => a - b);
    
    // ê²€ìƒ‰ ì„±ëŠ¥ ë¹„êµ
    const searchValues = Array.from({length: 1000}, () => Math.floor(Math.random() * size * 10));
    
    // BST ê²€ìƒ‰
    start = performance.now();
    searchValues.forEach(val => bst.search(val));
    end = performance.now();
    const bstSearchTime = end - start;
    
    // ë°°ì—´ ê²€ìƒ‰ (includes)
    start = performance.now();
    searchValues.forEach(val => arr.includes(val));
    end = performance.now();
    const arraySearchTime = end - start;
    
    // ì´ì§„ íƒìƒ‰
    function binarySearch(arr, target) {
        let left = 0, right = arr.length - 1;
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            if (arr[mid] === target) return true;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return false;
    }
    
    start = performance.now();
    searchValues.forEach(val => binarySearch(sortedArr, val));
    end = performance.now();
    const binarySearchTime = end - start;
    
    console.log(`=== ì‚½ì… ì„±ëŠ¥ ===`);
    console.log(`BST: ${bstInsertTime.toFixed(2)}ms`);
    console.log(`ë°°ì—´: ${arrayInsertTime.toFixed(2)}ms`);
    
    console.log(`\n=== ê²€ìƒ‰ ì„±ëŠ¥ ===`);
    console.log(`BST: ${bstSearchTime.toFixed(2)}ms`);
    console.log(`ë°°ì—´ includes: ${arraySearchTime.toFixed(2)}ms`);
    console.log(`ì´ì§„ íƒìƒ‰: ${binarySearchTime.toFixed(2)}ms`);
}
```

> BSTëŠ” í‰ê· ì ìœ¼ë¡œ O(log n) ì„±ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ, ë¶ˆê· í˜•í•  ë•ŒëŠ” O(n)ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ê· í˜• ì´ì§„ íŠ¸ë¦¬

### AVL íŠ¸ë¦¬ (ê°„ë‹¨í•œ ë²„ì „)

```javascript
class AVLNode extends TreeNode {
    constructor(val) {
        super(val);
        this.height = 1;
    }
}

class AVLTree {
    constructor() {
        this.root = null;
    }
    
    getHeight(node) {
        return node ? node.height : 0;
    }
    
    getBalance(node) {
        return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0;
    }
    
    updateHeight(node) {
        if (node) {
            node.height = Math.max(this.getHeight(node.left), this.getHeight(node.right)) + 1;
        }
    }
    
    rotateRight(y) {
        const x = y.left;
        const T2 = x.right;
        
        x.right = y;
        y.left = T2;
        
        this.updateHeight(y);
        this.updateHeight(x);
        
        return x;
    }
    
    rotateLeft(x) {
        const y = x.right;
        const T2 = y.left;
        
        y.left = x;
        x.right = T2;
        
        this.updateHeight(x);
        this.updateHeight(y);
        
        return y;
    }
    
    insert(val) {
        this.root = this.insertNode(this.root, val);
    }
    
    insertNode(node, val) {
        // 1. ì¼ë°˜ì ì¸ BST ì‚½ì…
        if (!node) return new AVLNode(val);
        
        if (val < node.val) {
            node.left = this.insertNode(node.left, val);
        } else if (val > node.val) {
            node.right = this.insertNode(node.right, val);
        } else {
            return node; // ì¤‘ë³µ ê°’
        }
        
        // 2. ë†’ì´ ì—…ë°ì´íŠ¸
        this.updateHeight(node);
        
        // 3. ê· í˜• ì¸ìˆ˜ ê³„ì‚°
        const balance = this.getBalance(node);
        
        // 4. ë¶ˆê· í˜• ì‹œ íšŒì „
        // Left Left Case
        if (balance > 1 && val < node.left.val) {
            return this.rotateRight(node);
        }
        
        // Right Right Case
        if (balance < -1 && val > node.right.val) {
            return this.rotateLeft(node);
        }
        
        // Left Right Case
        if (balance > 1 && val > node.left.val) {
            node.left = this.rotateLeft(node.left);
            return this.rotateRight(node);
        }
        
        // Right Left Case
        if (balance < -1 && val < node.right.val) {
            node.right = this.rotateRight(node.right);
            return this.rotateLeft(node);
        }
        
        return node;
    }
}

// AVL vs BST ì„±ëŠ¥ ë¹„êµ
function compareAVLvsBST() {
    const values = Array.from({length: 1000}, (_, i) => i); // ìˆœì°¨ ë°ì´í„° (ìµœì•…ì˜ ê²½ìš°)
    
    // ì¼ë°˜ BST
    const bst = new BinarySearchTree();
    let start = performance.now();
    values.forEach(val => bst.insert(val));
    let end = performance.now();
    const bstTime = end - start;
    
    // AVL íŠ¸ë¦¬
    const avl = new AVLTree();
    start = performance.now();
    values.forEach(val => avl.insert(val));
    end = performance.now();
    const avlTime = end - start;
    
    console.log(`BST ì‚½ì… (ìˆœì°¨ ë°ì´í„°): ${bstTime.toFixed(2)}ms`);
    console.log(`AVL ì‚½ì… (ìˆœì°¨ ë°ì´í„°): ${avlTime.toFixed(2)}ms`);
    
    // íŠ¸ë¦¬ ë†’ì´ ë¹„êµ
    function getTreeHeight(node) {
        if (!node) return 0;
        return Math.max(getTreeHeight(node.left), getTreeHeight(node.right)) + 1;
    }
    
    console.log(`BST ë†’ì´: ${getTreeHeight(bst.root)}`);
    console.log(`AVL ë†’ì´: ${getTreeHeight(avl.root)}`);
}
```

> AVL íŠ¸ë¦¬ëŠ” í•­ìƒ ê· í˜•ì„ ìœ ì§€í•˜ë¯€ë¡œ ìµœì•…ì˜ ê²½ìš°ì—ë„ O(log n) ì„±ëŠ¥ì„ ë³´ì¥í•©ë‹ˆë‹¤

## íŠ¸ë¦¬ ë¬¸ì œ í•´ê²°

### íŠ¸ë¦¬ì˜ ê¹Šì´ì™€ ë†’ì´

```javascript
// ìµœëŒ€ ê¹Šì´ (ë†’ì´)
function maxDepth(root) {
    if (!root) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}

// ìµœì†Œ ê¹Šì´
function minDepth(root) {
    if (!root) return 0;
    if (!root.left) return minDepth(root.right) + 1;
    if (!root.right) return minDepth(root.left) + 1;
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}

// ê· í˜• íŠ¸ë¦¬ ê²€ì‚¬
function isBalanced(root) {
    function checkBalance(node) {
        if (!node) return 0;
        
        const left = checkBalance(node.left);
        if (left === -1) return -1;
        
        const right = checkBalance(node.right);
        if (right === -1) return -1;
        
        if (Math.abs(left - right) > 1) return -1;
        
        return Math.max(left, right) + 1;
    }
    
    return checkBalance(root) !== -1;
}

const tree = createSampleTree();
console.log(`ìµœëŒ€ ê¹Šì´: ${maxDepth(tree)}`); // 3
console.log(`ìµœì†Œ ê¹Šì´: ${minDepth(tree)}`); // 3
console.log(`ê· í˜• íŠ¸ë¦¬: ${isBalanced(tree)}`); // true
```

### ê²½ë¡œì™€ í•©

```javascript
// ë£¨íŠ¸ì—ì„œ ìê¹Œì§€ì˜ ëª¨ë“  ê²½ë¡œ
function allPaths(root) {
    const paths = [];
    
    function dfs(node, currentPath) {
        if (!node) return;
        
        currentPath.push(node.val);
        
        if (!node.left && !node.right) {
            paths.push([...currentPath]);
        } else {
            dfs(node.left, currentPath);
            dfs(node.right, currentPath);
        }
        
        currentPath.pop();
    }
    
    dfs(root, []);
    return paths;
}

// íŠ¹ì • í•©ì„ ê°€ì§€ëŠ” ê²½ë¡œ ì°¾ê¸°
function hasPathSum(root, targetSum) {
    if (!root) return false;
    
    if (!root.left && !root.right) {
        return root.val === targetSum;
    }
    
    const remainingSum = targetSum - root.val;
    return hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);
}

// ìµœëŒ€ ê²½ë¡œ í•©
function maxPathSum(root) {
    let maxSum = -Infinity;
    
    function dfs(node) {
        if (!node) return 0;
        
        const left = Math.max(0, dfs(node.left));
        const right = Math.max(0, dfs(node.right));
        
        const currentMax = node.val + left + right;
        maxSum = Math.max(maxSum, currentMax);
        
        return node.val + Math.max(left, right);
    }
    
    dfs(root);
    return maxSum;
}

console.log(allPaths(tree));
console.log(hasPathSum(tree, 7)); // true (1->2->4)
```

### íŠ¸ë¦¬ ë³€í™˜

```javascript
// íŠ¸ë¦¬ ë’¤ì§‘ê¸° (ì¢Œìš° ë°˜ì „)
function invertTree(root) {
    if (!root) return null;
    
    [root.left, root.right] = [root.right, root.left];
    
    invertTree(root.left);
    invertTree(root.right);
    
    return root;
}

// íŠ¸ë¦¬ë¥¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ í‰íƒ„í™”
function flattenToLinkedList(root) {
    if (!root) return;
    
    flattenToLinkedList(root.left);
    flattenToLinkedList(root.right);
    
    const tempRight = root.right;
    root.right = root.left;
    root.left = null;
    
    let current = root;
    while (current.right) {
        current = current.right;
    }
    current.right = tempRight;
}

// ë°°ì—´ì—ì„œ íŠ¸ë¦¬ êµ¬ì„±
function arrayToTree(arr) {
    if (!arr.length) return null;
    
    const root = new TreeNode(arr[0]);
    const queue = [root];
    let i = 1;
    
    while (queue.length > 0 && i < arr.length) {
        const node = queue.shift();
        
        if (i < arr.length && arr[i] !== null) {
            node.left = new TreeNode(arr[i]);
            queue.push(node.left);
        }
        i++;
        
        if (i < arr.length && arr[i] !== null) {
            node.right = new TreeNode(arr[i]);
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
}

const arrayTree = arrayToTree([1, 2, 3, 4, 5, null, 6]);
console.log(levelOrderTraversal(arrayTree)); // [1, 2, 3, 4, 5, 6]
```

## íŠ¹ìˆ˜í•œ íŠ¸ë¦¬ë“¤

### íŠ¸ë¼ì´ (Trie) - ë¬¸ìì—´ ê²€ìƒ‰ íŠ¸ë¦¬

```javascript
class TrieNode {
    constructor() {
        this.children = {};
        this.isEndOfWord = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }
    
    insert(word) {
        let current = this.root;
        
        for (let char of word) {
            if (!current.children[char]) {
                current.children[char] = new TrieNode();
            }
            current = current.children[char];
        }
        
        current.isEndOfWord = true;
    }
    
    search(word) {
        let current = this.root;
        
        for (let char of word) {
            if (!current.children[char]) {
                return false;
            }
            current = current.children[char];
        }
        
        return current.isEndOfWord;
    }
    
    startsWith(prefix) {
        let current = this.root;
        
        for (let char of prefix) {
            if (!current.children[char]) {
                return false;
            }
            current = current.children[char];
        }
        
        return true;
    }
    
    getAllWords() {
        const words = [];
        
        function dfs(node, currentWord) {
            if (node.isEndOfWord) {
                words.push(currentWord);
            }
            
            for (let char in node.children) {
                dfs(node.children[char], currentWord + char);
            }
        }
        
        dfs(this.root, '');
        return words;
    }
}

// ìë™ì™„ì„± ê¸°ëŠ¥
function autoComplete(trie, prefix) {
    let current = trie.root;
    
    // ì ‘ë‘ì‚¬ê¹Œì§€ ì´ë™
    for (let char of prefix) {
        if (!current.children[char]) {
            return [];
        }
        current = current.children[char];
    }
    
    // ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ëª¨ë“  ë‹¨ì–´ ì°¾ê¸°
    const suggestions = [];
    
    function dfs(node, currentWord) {
        if (node.isEndOfWord) {
            suggestions.push(prefix + currentWord);
        }
        
        for (let char in node.children) {
            dfs(node.children[char], currentWord + char);
        }
    }
    
    dfs(current, '');
    return suggestions;
}

// ì‚¬ìš© ì˜ˆì‹œ
const trie = new Trie();
const words = ['apple', 'app', 'application', 'apply', 'banana', 'band'];
words.forEach(word => trie.insert(word));

console.log(trie.search('app')); // true
console.log(trie.startsWith('app')); // true
console.log(autoComplete(trie, 'app')); // ['apple', 'app', 'application', 'apply']
```

### ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ (êµ¬ê°„ í•© íŠ¸ë¦¬)

```javascript
class SegmentTree {
    constructor(arr) {
        this.n = arr.length;
        this.tree = Array(4 * this.n).fill(0);
        this.build(arr, 0, 0, this.n - 1);
    }
    
    build(arr, node, start, end) {
        if (start === end) {
            this.tree[node] = arr[start];
        } else {
            const mid = Math.floor((start + end) / 2);
            this.build(arr, 2 * node + 1, start, mid);
            this.build(arr, 2 * node + 2, mid + 1, end);
            this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];
        }
    }
    
    update(index, value) {
        this.updateHelper(0, 0, this.n - 1, index, value);
    }
    
    updateHelper(node, start, end, index, value) {
        if (start === end) {
            this.tree[node] = value;
        } else {
            const mid = Math.floor((start + end) / 2);
            if (index <= mid) {
                this.updateHelper(2 * node + 1, start, mid, index, value);
            } else {
                this.updateHelper(2 * node + 2, mid + 1, end, index, value);
            }
            this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];
        }
    }
    
    query(left, right) {
        return this.queryHelper(0, 0, this.n - 1, left, right);
    }
    
    queryHelper(node, start, end, left, right) {
        if (right < start || end < left) {
            return 0; // ë²”ìœ„ ë°–
        }
        
        if (left <= start && end <= right) {
            return this.tree[node]; // ì™„ì „íˆ í¬í•¨
        }
        
        const mid = Math.floor((start + end) / 2);
        const leftSum = this.queryHelper(2 * node + 1, start, mid, left, right);
        const rightSum = this.queryHelper(2 * node + 2, mid + 1, end, left, right);
        
        return leftSum + rightSum;
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
const arr = [1, 3, 5, 7, 9, 11];
const segTree = new SegmentTree(arr);

console.log(segTree.query(1, 3)); // 3 + 5 + 7 = 15
segTree.update(1, 10);
console.log(segTree.query(1, 3)); // 10 + 5 + 7 = 22
```

## ì‹¤ì œ ë¬¸ì œ ì‘ìš©

### ê°€ì¥ ê°€ê¹Œìš´ ê³µí†µ ì¡°ìƒ

```javascript
function lowestCommonAncestor(root, p, q) {
    if (!root || root === p || root === q) {
        return root;
    }
    
    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);
    
    if (left && right) return root;
    return left || right;
}

// BSTì—ì„œì˜ LCA (ë” íš¨ìœ¨ì )
function lowestCommonAncestorBST(root, p, q) {
    while (root) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else {
            return root;
        }
    }
    return null;
}
```

### ì§ë ¬í™”ì™€ ì—­ì§ë ¬í™”

```javascript
function serialize(root) {
    const result = [];
    
    function preorder(node) {
        if (!node) {
            result.push('null');
            return;
        }
        
        result.push(node.val.toString());
        preorder(node.left);
        preorder(node.right);
    }
    
    preorder(root);
    return result.join(',');
}

function deserialize(data) {
    const values = data.split(',');
    let index = 0;
    
    function buildTree() {
        if (values[index] === 'null') {
            index++;
            return null;
        }
        
        const node = new TreeNode(parseInt(values[index]));
        index++;
        
        node.left = buildTree();
        node.right = buildTree();
        
        return node;
    }
    
    return buildTree();
}

// ì‚¬ìš© ì˜ˆì‹œ
const originalTree = createSampleTree();
const serialized = serialize(originalTree);
console.log(serialized); // "1,2,4,null,null,5,null,null,3,6,null,null,7,null,null"

const deserializedTree = deserialize(serialized);
console.log(levelOrderTraversal(deserializedTree)); // [1, 2, 3, 4, 5, 6, 7]
```

## íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ê°€ì´ë“œ

```javascript
function chooseTreeAlgorithm() {
    console.log("íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ ì„ íƒ ê°€ì´ë“œ:");
    
    console.log("\nğŸ” ê²€ìƒ‰ì´ ì£¼ëª©ì :");
    console.log("- ê· í˜• BST (AVL, Red-Black)");
    console.log("- í•´ì‹œ í…Œì´ë¸”ê³¼ ë¹„êµ ê³ ë ¤");
    
    console.log("\nğŸ“ ë¬¸ìì—´ ê²€ìƒ‰:");
    console.log("- íŠ¸ë¼ì´ (Trie)");
    console.log("- ìë™ì™„ì„±, ì‚¬ì „ ê¸°ëŠ¥");
    
    console.log("\nğŸ“Š êµ¬ê°„ ì¿¼ë¦¬:");
    console.log("- ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬");
    console.log("- íœìœ… íŠ¸ë¦¬ (Binary Indexed Tree)");
    
    console.log("\nğŸŒ³ ì¼ë°˜ì ì¸ ê³„ì¸µ êµ¬ì¡°:");
    console.log("- ì´ì§„ íŠ¸ë¦¬");
    console.log("- N-ary íŠ¸ë¦¬");
    
    console.log("\nâš¡ ì„±ëŠ¥ íŠ¹ì„±:");
    console.log("- BST: í‰ê·  O(log n), ìµœì•… O(n)");
    console.log("- ê· í˜• íŠ¸ë¦¬: í•­ìƒ O(log n)");
    console.log("- íŠ¸ë¼ì´: O(m) (mì€ ë¬¸ìì—´ ê¸¸ì´)");
}
```

íŠ¸ë¦¬ëŠ” ê³„ì¸µì  ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ë¬¸ì œì˜ íŠ¹ì„±ì— ë§ëŠ” íŠ¸ë¦¬ êµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜ì„ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.
